# Supabase Migration Strategy

This document outlines our approach to managing database migrations in our Supabase project.

## Migration Principles

1. **Idempotent Migrations**: All migrations should be designed to be idempotent, meaning they can be run multiple times without causing errors or changing the result beyond the first application.

2. **Timestamp-based Naming**: Migration files follow the format `<timestamp>_<descriptive_name>.sql` to ensure proper ordering and tracking. Always use the full timestamp format generated by the Supabase CLI (e.g., `20250227183244_add_column.sql`).

3. **Version Control**: All migrations are stored in the `supabase/migrations` directory and tracked in Git.

4. **Automated Deployment**: Migrations are automatically deployed via GitHub Actions when changes are pushed to feature branches or main.

5. **One Change, One Migration**: Each logical change should have its own migration file. Avoid creating multiple migration files that make the same change.

6. **Consolidated Approach**: For complex changes or fixing migration history issues, use a consolidated approach that ensures schema correctness, fixes permissions, and repairs migration history in a single file.

## Creating New Migrations

To create a new migration:

1. Use the Supabase CLI to generate a migration file:
   ```bash
   supabase migration new <descriptive_name>
   ```
   This will create a file with the proper timestamp format.

2. Edit the generated file in `supabase/migrations` to include your SQL changes.

3. Make your migration idempotent by using conditional logic:
   ```sql
   -- For creating tables
   CREATE TABLE IF NOT EXISTS api.my_table (
     id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
     created_at timestamptz NOT NULL DEFAULT now()
   );

   -- For adding columns
   DO $$
   BEGIN
     IF NOT EXISTS (
       SELECT FROM information_schema.columns 
       WHERE table_schema = 'api' 
       AND table_name = 'my_table' 
       AND column_name = 'new_column'
     ) THEN
       ALTER TABLE api.my_table ADD COLUMN new_column text;
     END IF;
   END
   $$;
   ```

4. Test your migration locally:
   ```bash
   supabase db reset
   ```

## Handling Migration Errors

### Duplicate Key Errors

If you encounter a "duplicate key value violates unique constraint" error when running migrations, it typically means the migration has already been applied but isn't properly recorded in the migration history table.

To resolve this:

1. **Verify Schema State**: First, verify that the expected schema changes are actually present in the database:
   ```sql
   SELECT column_name 
   FROM information_schema.columns 
   WHERE table_schema = 'api' 
   AND table_name = 'your_table' 
   AND column_name = 'your_column';
   ```

2. **Repair Migration History**: If the schema is correct but the migration history is out of sync, use the repair command:
   ```bash
   supabase migration repair --status applied <timestamp>
   ```

3. **Our CI/CD Pipeline**: Our GitHub Actions workflow includes automated handling for duplicate key errors by:
   - Detecting migration failures
   - Verifying that expected schema changes exist
   - Trying more aggressive approaches like `--include-all`
   - Applying migrations directly via SQL if needed
   - Marking migrations as applied in the migration history

### Migration History Mismatches

If local and remote migration histories diverge:

1. **List Migrations**: Compare local and remote migrations:
   ```bash
   supabase migration list        # Local migrations
   supabase migration list --db-only  # Remote migrations
   ```

2. **Find Common Point**: Identify the latest common migration between local and remote.

3. **Repair from Common Point**: Use the repair command to synchronize from the common point:
   ```bash
   supabase migration repair --status reverted <problematic_timestamp>
   ```

4. **Simplified Approach**: For persistent issues, create a dedicated repair migration:
   ```sql
   -- 20250227184420_repair_migration_history.sql
   
   -- Remove the problematic migration if it exists
   DELETE FROM supabase_migrations.schema_migrations 
   WHERE version = '<problematic_timestamp>';
   
   -- Ensure the consolidated migration is in the history
   INSERT INTO supabase_migrations.schema_migrations (version, name, statements)
   VALUES (
     '<correct_timestamp>', 
     '<migration_name>',
     ARRAY['-- Migration description']
   )
   ON CONFLICT (version) DO NOTHING;
   ```

5. **GitHub Actions Integration**: Our CI/CD pipeline now includes specific handling for migration history mismatches:
   - Detecting "Remote migration versions not found in local migrations directory" errors
   - Automatically repairing the migration history using `supabase migration repair`
   - Retrying the migration push after repair

## Best Practices

1. **Small, Focused Migrations**: Keep migrations small and focused on a single logical change.

2. **Always Include Permissions**: When creating new tables or columns, include appropriate permissions and RLS policies in the same migration.

3. **Test Locally First**: Always test migrations locally before pushing to remote environments.

4. **Document Schema Changes**: Update relevant documentation when making schema changes.

5. **Handle Errors Gracefully**: Our CI/CD pipeline includes error handling for common migration issues, but be prepared to manually intervene when necessary.

6. **Avoid Duplicate Migrations**: Never create multiple migrations that make the same change. This causes conflicts in the migration history.

7. **Use Full Timestamps**: Always use the full timestamp format generated by the Supabase CLI. Avoid manually creating migration files with partial timestamps.

8. **Make Migrations Idempotent**: Always use conditional logic (IF EXISTS, IF NOT EXISTS, etc.) to ensure migrations can be run multiple times without errors.

9. **Include Comments**: Add clear comments to your migrations explaining what they do and why.

10. **Verify Schema After Deployment**: Always verify that your schema changes were applied correctly after deployment.

11. **Use DO Blocks for Complex Logic**: For complex migrations, use DO blocks to encapsulate logic and handle errors gracefully.

12. **Avoid Direct Schema Manipulation**: Don't use direct SQL commands to modify the schema outside of the migration process.

13. **Keep Migration History Clean**: Regularly check and maintain the migration history to ensure it's accurate and up-to-date.

14. **Use Transactions for Related Changes**: Wrap related changes in a transaction to ensure they're applied atomically.

15. **Consider Data Migration Impact**: Be mindful of how schema changes might affect existing data.

16. **Consolidate When Necessary**: When facing complex migration issues, use a consolidated approach that ensures schema correctness, fixes permissions, and repairs migration history in a single file.

## Troubleshooting

### Common Issues and Solutions

1. **Migration Already Applied**: If you get an error that a migration is already applied but it's not in your history:
   ```bash
   supabase migration repair --status applied <timestamp>
   ```

2. **Schema Drift**: If the actual database schema doesn't match what your migrations would create:
   ```bash
   # Generate a diff
   supabase db diff > schema_diff.sql
   
   # Review the diff and create a new migration if needed
   supabase migration new fix_schema_drift
   ```

3. **Reset Local Database**: If your local database is in a bad state:
   ```bash
   supabase db reset
   ```

4. **Manually Verify Schema**: Sometimes it's necessary to directly check the database schema:
   ```bash
   supabase db remote psql
   
   # Then in the psql console
   \dt api.*
   \d api.table_name
   ```

5. **Multiple Migrations Conflict**: If you have multiple migrations trying to make the same change:
   - Remove the redundant migrations
   - Create a consolidated fix migration
   - Use the `--include-all` flag when pushing

6. **Timestamp Format Issues**: If you're seeing errors related to timestamp formats:
   - Always use the Supabase CLI to generate migration files
   - Avoid manually creating migration files
   - Use the full timestamp format (e.g., `20250227183244_name.sql`)

7. **Permission Errors**: If you're seeing permission errors:
   - Make sure your migrations include the necessary GRANT statements
   - Check that RLS policies are correctly defined
   - Verify that the appropriate roles have access to the schema and tables

8. **Migration History Corruption**: If the migration history is corrupted:
   ```bash
   # Create a consolidated fix migration
   supabase migration new consolidated_fix
   
   # Add code to manually insert records into schema_migrations table
   ```

### Advanced Troubleshooting

#### Manually Fixing Migration History

In some cases, you may need to manually fix the migration history by directly modifying the `schema_migrations` table:

```sql
-- Check current migration history
SELECT * FROM supabase_migrations.schema_migrations ORDER BY version;

-- Add a missing migration
INSERT INTO supabase_migrations.schema_migrations (version, name, statements)
VALUES ('20250227183244', 'consolidated_fix', ARRAY['-- Migration added manually']);

-- Remove a problematic migration
DELETE FROM supabase_migrations.schema_migrations WHERE version = '20250227_problematic';
```

#### Creating Consolidated Fix Migrations

When dealing with complex migration issues, it's often helpful to create a consolidated fix migration that:

1. Ensures the schema is in the correct state
2. Fixes any permissions or RLS policies
3. Repairs the migration history

Example:

```sql
-- Migration: consolidated_fix
-- Created at: 2025-02-27 18:32:44

-- PART 1: Ensure schema is correct
DO $$ 
BEGIN 
  IF NOT EXISTS (
    SELECT FROM information_schema.columns 
    WHERE table_schema = 'api' 
    AND table_name = 'my_table' 
    AND column_name = 'my_column'
  ) THEN
    ALTER TABLE api.my_table ADD COLUMN my_column TEXT;
  END IF;
END $$;

-- PART 2: Fix permissions and RLS
GRANT USAGE ON SCHEMA api TO anon, authenticated;
GRANT SELECT ON api.my_table TO anon, authenticated;
GRANT INSERT, UPDATE, DELETE ON api.my_table TO authenticated;

ALTER TABLE api.my_table ENABLE ROW LEVEL SECURITY;

-- PART 3: Fix migration history
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM supabase_migrations.schema_migrations 
    WHERE version = '20250227183244'
  ) THEN
    INSERT INTO supabase_migrations.schema_migrations (version, name, statements)
    VALUES ('20250227183244', 'consolidated_fix', ARRAY['-- Consolidated fix migration']);
  END IF;
END $$;
```

## Migration Deployment Flow

Our GitHub Actions workflow (`supabase-deploy.yml`) handles migration deployment with the following flow:

1. **Pull Requests**: Validates migrations without applying them.
2. **Feature Branches**: Deploys to the preview environment.
3. **Main Branch**: Deploys to the production environment.

The workflow includes robust error handling for common migration issues, including duplicate key errors and migration history mismatches.

### Workflow Features

Our deployment workflow includes several advanced features:

1. **Idempotency Validation**: Checks that migrations use idempotent patterns like IF EXISTS.
2. **Schema Verification**: Verifies that expected schema changes are present after deployment.
3. **Direct SQL Application**: Falls back to direct SQL application when standard methods fail.
4. **Migration History Repair**: Automatically repairs the migration history when needed.
5. **Comprehensive Error Handling**: Handles common errors gracefully with detailed logging.
6. **Retry Mechanisms**: Implements intelligent retry logic for transient failures.
7. **Environment-Specific Logic**: Adapts deployment strategy based on the target environment.
8. **Validation Steps**: Includes pre and post-deployment validation to ensure schema integrity.

## Lessons Learned

From our experience with Supabase migrations, we've learned several important lessons:

1. **Always Use Idempotent Migrations**: Non-idempotent migrations cause headaches when reapplied.
2. **Maintain Clean Migration History**: A clean migration history is crucial for smooth deployments.
3. **Verify Schema Changes**: Always verify that schema changes were applied correctly.
4. **Handle Errors Gracefully**: Robust error handling in CI/CD pipelines saves time and reduces stress.
5. **Document Migration Strategies**: Clear documentation helps the team understand and follow best practices.
6. **Use Consistent Naming**: Consistent naming conventions make migrations easier to track and manage.
7. **Test Locally First**: Always test migrations locally before pushing to remote environments.
8. **Be Careful with Timestamps**: Inconsistent timestamp formats can cause ordering issues.
9. **Include Permissions in Migrations**: Always include necessary permissions and RLS policies in migrations.
10. **Use Consolidated Fix Migrations**: When migration history gets out of sync, consolidated fix migrations can save the day.
11. **Avoid Multiple Migrations for Same Change**: Creating multiple migrations for the same change leads to conflicts.
12. **Implement Robust CI/CD**: A well-designed CI/CD pipeline with error handling is essential for reliable deployments.
13. **Keep Migrations Simple**: Complex migrations are harder to debug and more likely to fail.
14. **Monitor Migration History**: Regularly check migration history to catch issues early.
15. **Understand Supabase CLI Behavior**: Different Supabase CLI commands handle migrations differently.

## Recent Improvements

We've recently made significant improvements to our migration strategy:

1. **Simplified GitHub Actions Workflow**: Removed complex functions and direct database manipulation in favor of using Supabase CLI's built-in repair commands.

2. **Dedicated Repair Migrations**: Created dedicated migration files for repairing migration history issues that can be applied idempotently.

3. **Improved Error Detection**: Enhanced our CI/CD pipeline to detect specific migration errors and apply appropriate fixes automatically.

4. **Consolidated Migrations**: For complex changes, we now use a consolidated approach that ensures all schema changes, permissions, and migration history repairs are handled in a cohesive way.

5. **Idempotent Design**: All migrations are now designed to be fully idempotent, with explicit checks before making any changes.

## Best Practices for Avoiding Migration Issues

1. **Always Use the CLI**: Generate migration files using the Supabase CLI rather than creating them manually:
   ```bash
   supabase migration new my_migration_name
   ```

2. **Keep Migrations Small**: Break down large changes into smaller, more manageable migrations.

3. **Test Thoroughly**: Test migrations locally and in a staging environment before deploying to production.

4. **Monitor Migration History**: Regularly check migration history to catch issues early.

5. **Use Version Control**: Store migrations in version control to track changes and collaborate with the team.

6. **Document Changes**: Document schema changes and migration strategies to ensure knowledge sharing and consistency.

7. **Avoid Manual Edits**: Avoid making manual edits to the database schema or migration history.

8. **Use Automated Deployment**: Use automated deployment tools like GitHub Actions to streamline the deployment process.

9. **Implement Rollbacks**: Implement rollback strategies for migrations to quickly recover from errors.

10. **Continuously Improve**: Continuously improve and refine your migration strategy based on lessons learned and best practices.
